import discord
import random
import hashlib # For proper hashing
import logging

# Adjust import path if necessary
from .parsing_pipeline import stage0, stage1, stage2, stage3

logger = logging.getLogger(__name__)

class EndScreen :

    def __init__ (self) :
        self.img = None # Consider if you actually need to store the image object
        self.raw_result = None # Store raw OCR if needed for debugging
        self.winners = []
        self.losers = []
        self.alliance = None # Not currently parsed/used?
        self.prism = None # Boolean: True if prism fight, False otherwise
        self.perco = None # Boolean: True if perco fight, False otherwise
        self.wewon = None # Boolean: True if KNOWN_NAMES are winners, False if losers, None if unknown/not involved
        self.hash_code = None # Will be generated by hash() method
        self.time = -1 # Initialize fight duration (if parsed later)

    def concat (self, other: 'EndScreen'):
        """
        Concatenates results from another EndScreen, typically representing
        another part of the same fight screenshot.
        Merges winners and losers lists. Assumes they are part of the same fight.
        """
        # Basic check: Don't merge if fight types conflict (e.g., one prism, one perco)
        # This assumes types were correctly identified in both parts.
        if (self.prism is not None and other.prism is not None and self.prism != other.prism) or \
           (self.perco is not None and other.perco is not None and self.perco != other.perco):
            raise ValueError("Cannot concatenate: Fight types (Prism/Perco) conflict.")

        # Combine winners and losers, removing duplicates
        self.winners = sorted(list(set(self.winners) | set(other.winners)))
        self.losers = sorted(list(set(self.losers) | set(other.losers)))

        # How to merge 'wewon'? If one part says win and other says loss, it's inconsistent.
        # Maybe re-evaluate wewon based on the final merged lists?
        # For now, let's keep the 'wewon' from the first part, unless the second part contradicts.
        if self.wewon is None:
            self.wewon = other.wewon
        elif other.wewon is not None and self.wewon != other.wewon:
            logger.warning(f"Conflicting 'wewon' status during concatenation. Keeping first: {self.wewon}")
            # Or maybe set to None to indicate ambiguity?
            # self.wewon = None

        # Merge fight type (prioritize True if found in either)
        if self.prism is None: self.prism = other.prism
        elif other.prism is True: self.prism = True

        if self.perco is None: self.perco = other.perco
        elif other.perco is True: self.perco = True

        # Merge time? Take the max? Average? Requires parsing time first.
        # if other.time > self.time: self.time = other.time

        logger.info("Concatenated EndScreen results.")


    def __str__ (self) :
        # Existing __str__ seems fine, maybe add hash for debugging?
        base_str = super().__str__() # Get default object string
        details = f"Winners: {self.winners}, Losers: {self.losers}, Prism: {self.prism}, Perco: {self.perco}, WeWon: {self.wewon}, Hash: {self.hash()}"
        return f"{base_str} - {details}"

    def save(self, player_stats_list):
        """
        Updates statistics for players involved in the fight.
        player_stats_list: A list of objects, where each object represents a player
                           and has attributes to store their stats.
        """
        if not player_stats_list:
             logger.warning("Save called with empty player_stats_list.")
             return # No one to save stats for

        logger.info(f"Saving stats for {len(self.winners)} winners and {len(self.losers)} losers.")
        updated_players = []

        for player_obj in player_stats_list:
            # Ensure the object is usable
            if not hasattr(player_obj, 'name'):
                logger.warning(f"Skipping object in player_stats_list: missing 'name' attribute. Object: {player_obj}")
                continue

            player_name = player_obj.name
            is_winner = player_name in self.winners
            is_loser = player_name in self.losers

            # Skip if player wasn't in this fight result
            if not is_winner and not is_loser:
                continue

            # --- Ensure stat attributes exist (initialize if first time) ---
            # Using getattr with default 0 is safer than setattr if attributes might exist
            def ensure_attr(obj, attr_name, default_value=0):
                if not hasattr(obj, attr_name):
                    setattr(obj, attr_name, default_value)

            # Core stats
            ensure_attr(player_obj, 'prisme_fight_win')
            ensure_attr(player_obj, 'prisme_fight_total')
            ensure_attr(player_obj, 'perco_fight_win')
            ensure_attr(player_obj, 'perco_fight_total')
            ensure_attr(player_obj, 'prisme_fight_loose') # Added loose stats
            ensure_attr(player_obj, 'perco_fight_loose')  # Added loose stats

            # Unpaid stats
            ensure_attr(player_obj, 'prisme_won_unpaid')
            ensure_attr(player_obj, 'perco_won_unpaid')
            ensure_attr(player_obj, 'prisme_loose_unpaid')
            ensure_attr(player_obj, 'perco_loose_unpaid')

            # Change tracking flag
            ensure_attr(player_obj, 'haschanged', False) # Default is False
            # --- End attribute ensure ---

            player_updated = False
            if is_winner:
                if self.prism:
                    player_obj.prisme_fight_win += 1
                    player_obj.prisme_fight_total += 1
                    player_obj.prisme_won_unpaid += 1
                    player_updated = True
                elif self.perco: # Use elif assuming it's one or the other
                    player_obj.perco_fight_win += 1
                    player_obj.perco_fight_total += 1
                    player_obj.perco_won_unpaid += 1
                    player_updated = True
                # Else: Unknown fight type, maybe log or track separately?

            elif is_loser:
                if self.prism:
                    player_obj.prisme_fight_loose += 1
                    player_obj.prisme_fight_total += 1 # Also increment total on loss
                    player_obj.prisme_loose_unpaid += 1
                    player_updated = True
                elif self.perco:
                    player_obj.perco_fight_loose += 1
                    player_obj.perco_fight_total += 1 # Also increment total on loss
                    player_obj.perco_loose_unpaid += 1
                    player_updated = True
                # Else: Unknown fight type

            if player_updated:
                player_obj.haschanged = True
                updated_players.append(player_name)
                logger.debug(f"Updated stats for player: {player_name}")

        logger.info(f"Finished saving stats. Players updated: {updated_players}")


    def to_embed(self, timestamp_str=None) -> discord.Embed:
        # Determine color and result text based on win/loss/unknown
        if self.wewon is True:
            embed_color = discord.Color.green()
            result_emoji = "✅"
            result_text = "Victoire !"
        elif self.wewon is False:
            embed_color = discord.Color.red()
            result_emoji = "❌"
            result_text = "Défaite..."
        else: # None or other
            embed_color = discord.Color.greyple() # Grey for unknown/not involved
            result_emoji = "❓"
            result_text = "Résultat Indéterminé / Non Concerné" # Clarify meaning of None

        # Determine target type
        if self.prism is True:
            target_emoji = "💎"
            target_text = "Prisme"
        elif self.perco is True:
            target_emoji = "💰"
            target_text = "Percepteur"
        else:
            target_emoji = "❔"
            target_text = "Cible Inconnue"

        embed_desc = f"**{result_text}** contre un(e) **{target_text}**."

        embed = discord.Embed(
            title=f"{result_emoji} Résultat Combat vs {target_text} {result_emoji}",
            description=embed_desc,
            color=embed_color
        )

        # Ensure lists are not empty before joining
        winner_list = "\n".join(f"👤 {name}" for name in self.winners) if self.winners else "*(Aucun)*"
        embed.add_field(name="🏆 Gagnants", value=winner_list, inline=True)

        loser_list = "\n".join(f"👤 {name}" for name in self.losers) if self.losers else "*(Aucun)*"
        embed.add_field(name="💀 Perdants", value=loser_list, inline=True)

        # Add fight duration if available
        if self.time != -1:
             embed.add_field(name="⏱️ Durée", value=f"`{self.time} minutes`", inline=False)

        if timestamp_str:
            embed.set_footer(text=f"Message reçu à: {timestamp_str}")
        else:
            embed.set_footer(text=f"Hash: {self.hash()}") # Add hash to footer if no timestamp

        return embed

    def hash (self) -> str:
        return random.randint(0,100000000000000000000)

    def parse (self, words, positions, raw_ocr_lines, known_names, vocabulary, std_factor=4):
        """
        Parse the OCR words and positions to extract fight details.
        Assumes 'positions' contains approximate word coordinates (e.g., center point).
        Uses 'raw_ocr_lines' to determine prism/perco type first.
        """
        logger.info("Starting EndScreen parsing pipeline.")

        # --- Determine Fight Type based on RAW OCR output FIRST ---
        self.prism = False
        self.perco = False
        found_prism_keyword = False
        if raw_ocr_lines: # Check if list is not empty
            for text_line in raw_ocr_lines:
                # Check case-insensitively
                if "prisme" in text_line.lower() or "prism" in text_line.lower():
                    found_prism_keyword = True
                    break # Found it, no need to check further

        if found_prism_keyword:
            self.prism = True
            self.perco = False
            logger.info("Detected Prism fight based on raw OCR text ('prisme'/'prism' found).")
        else:
            self.perco = True # Default to perco if prism keyword not found anywhere
            self.prism = False
            logger.info("Defaulting to Percepteur fight ('prisme'/'prism' not found in raw OCR).")
        # --- End Fight Type Determination ---


        if not words:
            logger.warning("Parse called with empty words list. Setting empty results.")
            self.winners = []
            self.losers = []
            # Keep the already determined prism/perco status
            self.wewon = None
            return

        # --- Start Parsing Pipeline ---
        logger.debug("Running Stage 0: Preprocessing")
        processed_words, processed_positions = stage0(words, positions)
        if not processed_words:
             logger.warning("No words remaining after Stage 0 preprocessing.")
             self.winners, self.losers, self.wewon = [], [], None
             return

        logger.debug("Running Stage 1: Word to Known")
        mapped_words, final_positions = stage1(processed_words, processed_positions, vocabulary, threshold=3)

        logger.debug("Running Stage 2: Classification (Relaxed)")
        # Pass mapped_words, final_positions
        word_dict = stage2(mapped_words, final_positions, known_names, vocabulary, std_factor=std_factor) # std_factor might be less relevant now

        logger.debug("Running Stage 3: Winner/Loser Extraction (Corrected Logic)")
        # Pass the dict from stage 2
        # Stage 3 now returns winners, losers based on corrected logic
        winners, loosers = stage3(word_dict) # Corrected variable names in return

        # --- Determine if 'we' (known_names) won or lost ---
        # This logic remains the same, based on the output of stage3
        known_names_set = set(known_names)
        winners_set = set(winners)
        losers_set = set(loosers) # Corrected variable name

        we_are_winners = bool(winners_set & known_names_set)
        we_are_losers = bool(losers_set & known_names_set)

        if we_are_winners and not we_are_losers:
            self.wewon = True
            logger.info("Determined outcome: Win (known name in winners).")
        elif we_are_losers and not we_are_winners:
            self.wewon = False
            logger.info("Determined outcome: Loss (known name in losers).")
        elif we_are_winners and we_are_losers:
            logger.error("Inconsistent state: Known names found in both winners and losers! Check parsing stages.")
            self.wewon = None
        else:
            self.wewon = None
            logger.info("Determined outcome: Unknown / Not involved (no known names found).")

        # Store final lists (sorted for consistency)
        # Contains all names classified by stage3 (including unknowns)
        self.winners = sorted(list(winners_set))
        self.losers = sorted(list(losers_set))

        # Generate hash code after parsing is complete
        self.hash_code = self.hash()
        logger.info(f"Parsing complete. Hash: {self.hash_code}")
        logger.debug(f"Final parsed state: Winners={self.winners}, Losers={self.losers}, Prism={self.prism}, Perco={self.perco}, WeWon={self.wewon}")

    def _update_lists_and_sort(self):
        """Ensure lists are sets then sorted lists."""
        self.winners = sorted(list(set(self.winners)))
        self.losers = sorted(list(set(self.losers)))

    def add_winner(self, name: str):
        """Adds a name to winners, removes from losers if present."""
        if name: # Ensure name is not empty
            if name in self.losers:
                self.losers.remove(name)
            if name not in self.winners:
                self.winners.append(name)
            self._update_lists_and_sort()
            logger.info(f"Added '{name}' to winners.")
            return True
        return False

    def add_loser(self, name: str):
        """Adds a name to losers, removes from winners if present."""
        if name:
            if name in self.winners:
                self.winners.remove(name)
            if name not in self.losers:
                self.losers.append(name)
            self._update_lists_and_sort()
            logger.info(f"Added '{name}' to losers.")
            return True
        return False

    def remove_player(self, name: str):
        """Removes a name from both winners and losers lists."""
        removed = False
        if name in self.winners:
            self.winners.remove(name)
            removed = True
        if name in self.losers:
            self.losers.remove(name)
            removed = True
        if removed:
            self._update_lists_and_sort()
            logger.info(f"Removed '{name}' from results.")
        return removed

    def re_evaluate_wewon(self, known_names: list):
        """Updates the self.wewon status based on current winner/loser lists."""
        known_names_set = set(known_names)
        winners_set = set(self.winners)
        losers_set = set(self.losers)

        we_are_winners = bool(winners_set & known_names_set)
        we_are_losers = bool(losers_set & known_names_set)

        original_wewon = self.wewon
        if we_are_winners and not we_are_losers:
            self.wewon = True
        elif we_are_losers and not we_are_winners:
            self.wewon = False
        elif we_are_winners and we_are_losers:
            logger.error("Inconsistent state after modification: Known names in both winners and losers!")
            self.wewon = None # Ambiguous
        else:
            self.wewon = None # Not involved

        if original_wewon != self.wewon:
            logger.info(f"Re-evaluated 'wewon' status: {original_wewon} -> {self.wewon}")